#!/usr/bin/env ruby

require "rubygems"
require "bundler/setup"
require "cmux"

require "logger"
require "yaml"

class ModemMonitor
  def initialize(config)
    @config = config
    @state = :closed
    @mux = nil
    @chatter = nil
    @logger = Logger.new STDOUT
    @ppp_state = :stopped
    @ppp_pid = nil
    @ppp_channel = nil
  end

  def unsolicited(type, fields)
    case type
    when "CUSD"
      ussd *fields
    end
  end

  def ussd(mode, string = nil, dcs = nil)
    if mode != "0"
      @logger.warn "USSD completed with mode #{mode}, expected 0"
    end

    if string
      string = string.scan(/\w{4}/)
                    .map! { |i| [ i.hex ].pack("U") }
                    .join
                    .strip

      @logger.info "balance: #{string}"
    end
  end

  def run
    loop do
      case @state
      when :closed
        @logger.info "trying to open modem"
        begin
          @mux = CMUX::MUX.new @config[:device]
          @state = :open

          begin
            @status_channel = @mux.allocate(@config[:status_channel]).open
            @chatter = CMUX::ModemChatter.new @status_channel
            @chatter.subscribe "CUSD", self
          rescue Exception => e
            @mux.close
            @mux = nil
            @chatter = nil
            @state = :closed

            raise e
          end

          @logger.info "modem open"
          @network_counter = 0

        rescue Exception => e
          @logger.error "unable to open modem: " + e.to_s
        end

      when :open
        modem_works = nil

        @chatter.command("", 3) { |resp| modem_works = resp.success? }

        while modem_works.nil?
          CMUX::ModemChatter.poll [ @chatter ]
        end

        if !modem_works
          @logger.error "modem is not responding, closing session"

          begin
            if @ppp_state == :running
              @ppp_channel.close    # PPP will die by itself.
              @ppp_channel = nil
              @ppp_state = :stopped
              @ppp_pid = nil
            end

            @mux.close
          rescue Exception => e
            @logger.error "mux close failed: " + e.to_s
          end

          @mux = nil
          @chatter.unsubscribe "CUSD", self
          @chatter = nil
          @state = :closed
        else
          @logger.debug "tick"

          if @network_counter == 0 && @config.include?(:balance_ussd)
            @network_counter = @config[:balance_interval]

            @logger.info "requesting balance"

            @chatter.command("+CUSD=1,\"#{@config[:balance_ussd]}\",15", 1) do |resp|
              if resp.failure?
                @logger.error "USSD request failed: #{resp.error}"
              end

              done = true
            end

          else
            @network_counter -= 1
          end

          if @ppp_state == :stopped
            @logger.info "starting pppd"

            @ppp_channel = nil

            begin
              @ppp_channel = @mux.allocate @config[:ppp_channel]

              @ppp_pid = Process.spawn @config[:ppp_helper], @ppp_channel.device
              @ppp_state = :running

              @logger.info "started pppd, PID #{@ppp_pid}"
            rescue Exception => e
              @logger.warn "ppp startup failed: #{e.to_s}"
              begin
                @ppp_channel.close unless @ppp_channel.nil?
              rescue
              end
            end
          end
        end
      end

      if @state == :open
        CMUX::ModemChatter.poll [ @chatter ], @config[:poll_interval]
      else
        sleep @config[:poll_interval]
      end
    end
  end

  def process_died(pid)
    if @ppp_pid == pid
      @logger.warn "pppd died"
      @ppp_pid = nil
      @ppp_state = :stopped
      @ppp_channel.close
      @ppp_channel = nil
    else
      @logger.debug "#{pid} died"
    end
  end
end

config = YAML.load_file "config.yml"
monitor = ModemMonitor.new config


trap :CHLD do
  pids = []

  begin
    loop do
      pids << Process.wait(-1, Process::WNOHANG)
    end
  rescue
  end

  pids.each do |pid|
    monitor.process_died pid
  end
end

monitor.run